#![allow(dead_code)]

use crate::Address;

#[macro_use]
pub(crate) mod cpu;
pub(crate) mod cpzero;
mod instruction;
mod instructions;

type Register = usize;

/// Zero register
const REG_ZERO: Register = 0;
const REG_AT: Register = 1;
const REG_V0: Register = 2;
const REG_V1: Register = 3;
const REG_A0: Register = 4;
const REG_A1: Register = 5;
const REG_A2: Register = 6;
const REG_A3: Register = 7;
const REG_T0: Register = 8;
const REG_T1: Register = 9;
const REG_T2: Register = 10;
const REG_T3: Register = 11;
const REG_T4: Register = 12;
const REG_T5: Register = 13;
const REG_T6: Register = 14;
const REG_T7: Register = 15;
const REG_S0: Register = 16;
const REG_S1: Register = 17;
const REG_S2: Register = 18;
const REG_S3: Register = 19;
const REG_S4: Register = 20;
const REG_S5: Register = 21;
const REG_S6: Register = 22;
const REG_S7: Register = 23;
const REG_T8: Register = 24;
const REG_T9: Register = 25;
const REG_K0: Register = 26;
const REG_K1: Register = 27;
/// Global pointer
const REG_GP: Register = 28;
/// Stack pointer
const REG_SP: Register = 29;
/// Frame pointer
const REG_FP: Register = 30;
/// Return address register
const REG_RA: Register = 31;

/// Address mask for determining which segment the address belongs to
pub const KSEG_SELECT_MASK: Address = 0xe0000000;
/// Start address of kernel-space
pub const KERNEL_SPACE_MASK: Address = KSEG0;

/// Start address of TLB-mapped cacheable user or kernel space
pub const KUSEG: Address = 0;
/// Start of direct-mapped cacheable kernel space
pub const KSEG0: Address = 0x80000000;
/// Start of direct-mapped non-cacheable kernel space
pub const KSEG1: Address = 0xa0000000;
/// Start of TLB-mapped cacheable kernel space
pub const KSEG2: Address = 0xc0000000;
/// Second half of mapped and cached kernel segment
pub const KSEG2_TOP: Address = 0xe0000000;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ExceptionCode {
    /// Interrupt
    Interrupt = 0,
    /// TLB Modification
    TlbMod = 1,
    /// TLB Load
    TlbLoad = 2,
    /// TLB Store
    TlbStore = 3,
    /// Address error exception generated by a load instruction
    LoadAddressError = 4,
    /// Address error exception generated by a store instruction
    StoreAddressError = 5,
    /// Instruction Bus Error
    InstructionBusError = 6,
    /// Data Bus Error
    DataBusError = 7,
    /// Generated unconditionally by a syscall instruction
    Syscall = 8,
    /// Breakpoint instruction
    Break = 9,
    /// Reserved instruction
    ReservedInstruction = 10,
    /// Coprocessor unusable
    CoprocessorUnusable = 11,
    /// Arithmetic Overflow
    Overflow = 12,
    /// Trap instruction
    Trap = 13,
}
